# Wirebarly Test Project

이 프로젝트는 헥사고날 아키텍처(Hexagonal Architecture)를 기반으로 구축된 송금 시스템 서버 애플리케이션입니다.
Docker Compose를 사용하여 애플리케이션과 MySQL 데이터베이스를 손쉽게 실행할 수 있도록 구성되어 있습니다.

<br/>

## 🛠 Tech Stack

- **Java**: 21
- **Framework**: Spring Boot 3.5.9
- **Build Tool**: Gradle
- **Database**: MySQL 8.0
- **Containerization**: Docker, Docker Compose

<br/>

## 🔌  Library
- **lombok** : 보일러플레이트 코드를 줄이기 위해 프로젝트 전역에서 사용하였습니다.
- **Querydsl** : 다소 복잡한 쿼리의 경우, 컴파일 타임에 타입 체킹이 가능하고 어떤 쿼리가 나가는지 JPQL에 비해 예상 가능하다는 장점이 있어 활용하였습니다.

<br/>

## 📋 Prerequisites

프로젝트를 실행하기 위해 다음 도구들이 설치되어 있어야 합니다.

- [Docker](https://www.docker.com/get-started)
- [Docker Compose](https://docs.docker.com/compose/install/)

<br/>

## 🚀 Getting Started (Docker Compose)

Docker Compose를 사용하여 애플리케이션과 데이터베이스를 한 번에 빌드하고 실행할 수 있습니다.

### 0. 프로젝트 다운로드 (Clone)

```bash
git clone https://github.com/wirebarly/wirebarly-test.git
```

### 1. 실행 (Build & Run)

프로젝트 루트 디렉토리에서 아래 명령어를 실행해주세요.

```bash
docker-compose up -d --build
```


### 2. 상태 확인

컨테이너가 정상적으로 실행되었는지 확인합니다.

```bash
docker ps
```

두 개의 컨테이너가 **Up (healthy/running)** 상태여야 합니다.
- `wirebarly-app`: Spring Boot 애플리케이션 (Port: 9091)
- `wirebarly-db`: MySQL 데이터베이스 (Port: 7233 -> 3306)

### 3. 로그 확인

애플리케이션 로그를 실시간으로 확인하려면 아래 명령어를 사용해주세요.

```bash
docker logs -f wirebarly-app
```

### 4. 종료

실행 중인 컨테이너를 종료하고 삭제합니다.

```bash
docker-compose down
```

<br/>

## 🔌 API Verification

서버가 정상적으로 실행되면 `http://localhost:9091`에서 API에 접근할 수 있습니다.

### 계정 생성 테스트 (Curl)

```bash
curl -X POST http://localhost:9091/api/v1/accounts/new \
-H "Content-Type: application/json" \
-d '{
    "customerId": 1,
    "bankCode": "004",
    "accountNumber": "1234567890"
}'
```

성공 시 `200 OK` 응답을 받습니다.

<br/>

## 💾 Database Access

로컬에서 실행 중인 MySQL 데이터베이스에 접속하려면 아래 정보를 사용해주세요.

- **Host Link**: `localhost`
- **Port**: `7233` (컨테이너 내부 3306 포트가 호스트의 7233으로 매핑됨)
- **Database**: `wirebarly`
- **Username**: `root`
- **Password**: `root`

초기 데이터(`init.sql`)는 컨테이너 실행 시 자동으로 로드됩니다.

<br/>

## 📚 Documentation
- **API 명세서** : [Notion Link](https://www.notion.so/API-2dc64e392ce780c99ef3e8b7c50aff1c?source=copy_link)
- **ERD 클라우드** : [ERD Cloud Link](https://www.erdcloud.com/d/jDFFiK65vYm5S7DkW)

<br/>

<br/>

## ✨ Features

### 1. 계좌 관리 (Account Management)
- **계좌 개설**: 고객 ID, 은행 코드, 계좌 번호를 입력받아 새로운 계좌를 생성합니다.
- **계좌 해지**: 사용하지 않는 계좌를 안전하게 삭제(해지) 상태로 변경합니다.

### 2. 입출금 및 이체 (Transaction)
- **입금 (Deposit)**: 특정 계좌에 금액을 입금합니다.
- **출금 (Withdraw)**: 일일 출금 한도(1,000,000원) 내에서 출금을 수행합니다. 잔액 부족 시 요청이 거절됩니다.
- **이체 (Transfer)**: 
  - 타 계좌로 금액을 송금합니다.
  - **수수료**: 이체 금액의 1%가 수수료로 함께 차감됩니다.
  - **한도**: 일일 이체 한도(3,000,000원)를 초과할 수 없습니다.

### 3. 내역 조회 (History)
- **거래 내역 조회**: 특정 계좌의 모든 송금 및 수취 내역을 최신순으로 조회할 수 있습니다.

<br/>

## 📂 프로젝트 아키텍처
인프라 변경 등, 외부 환경의 변화에도 시스템의 핵심 규칙을 보존할 수 있도록 헥사고날 아키텍처를 적용하였습니다. 계층 간 독립성을 견고하게 유지할 수 있도록 멀티모듈 구조로 아래와 같이 설정했습니다.

### Adapter
- 웹, 영속성 관련 프레임워크나 라이브러리 등이 위치한 계층입니다.
- 크게 외부의 요청을 받는 **InboundAdapter**와 외부 시스템이나 라이브러리를 사용할 수 있는 **OutboundAdapter**가 존재합니다.


### Port
- **In** : HTTP 요청과 같이 외부 클라이언트가 우리 시스템을 사용하고자할 때, **UseCase** 명세를 제공하고 요청을 받아 내부 계층에 처리를 위임한뒤, 결과를 받아 응답을 돌려주는 역할을 합니다.
- **Out** : DB와 같이 우리 시스템이 외부 시스템을 호출하여 사용하고자할 때, 어떤 명세로 받을 것인지 정의하는 역할을 합니다. 이 계층을 통해 사용하는 외부 시스템이 변경되어도 일관된 구조로 우리 시스템이 사용할 수 있습니다.
- **상세 설명**
    - Application 계층이 온전히 비즈니스 로직 처리에 집중하여 담당할 수 있도록, 시스템 내/외부로 데이터를 전달하기 위한 계층을 정의해 별도로 분리했습니다.
    - 이 Port 계층을 추가함으로써 내부 레이어(Domain, Application)와 외부 레이어(Adapter)의 경계를 명료히 하고, 책임을 일원화할 수 있도록 하였습니다.

### Application
- 도메인 계층에 의존하여 애플리케이션에 특화된 규칙들을 정의하고, 도메인들을 가져와서 활용해 이를 적용하고 실행합니다.
- 반환 데이터가 필요하면 Adapter 계층으로 이를 내보냅니다.

### Domain
- 순수한 도메인 객체들을 가지고 있으며, lombok과 test 자동화를 위한 라이브러리를 제외하고, 다른 의존성이 존재하지 않습니다.
- 도메인 객체에는 비즈니스의 핵심 가치를 지닌 도메인 규칙 및 로직이 존재합니다.

<br/>

## 🧪  채번 전략
- 계좌번호는 계좌번호 체계 변경, 재발급 등의 정책 변경 및 보안·인프라 확장 가능성을 고려해 시스템 내부 식별자(AccountId)와 분리하였습니다.
- 추후 샤딩을 적용하는 등 인프라 변경 시, DB_AutoIncrement를 사용할 경우 중복 PK 값이 저장될 수 있으므로, Snowflake 방식을 사용해, DB 다중화가 되더라도 전역 유니크를 보장할 수 있도록 하였습니다.
- 알고리즘 수행 과정에서 nodeId 충돌이 발생할 수 있지만, 확률이 현저히 적으며 nodeId를 할당하는 중앙 시스템을 추가해 이를 사용하면 로직 상 큰 변경 없이 유일성 보장이 가능하다는 점을 고려하였습니다.

<br/>

## 📕 검증 전략
1. **외부 입력값 검증**
    - Adapter-Web 계층에 존재하는 컨트롤러에서 애플리케이션 내 최초로 접근하는 클라이언트의 입력값들을 1차적으로 검증합니다. 이 때 도메인 규칙이 계층 전역에 흩어지지 않도록 도메인 용어를 사용하지 않고, String이나 Long과 같은 nullable한 raw 값들을 사용하여 검증하고, 내부 계층으로 전달되도록 하였습니다.
2. **도메인 규칙 검증**
    - 기본적으로 각 도메인 객체와 하위의 VO들이 각각 생성될 때, 불변식을 체크하게끔하였습니다.
    - 출금이나 이체 한도 등, 도메인의 핵심적인 규칙들을 최대한 도메인 객체 내부에서 검증할 수 있도록 구성하고자 노력했습니다.
3. **비즈니스 수행 검증**
    - 애플리케이션 계층에서 비즈니스 로직을 전개할 때 발생하는 오류를 체크하였습니다.

<br/>

## 🔗 동시성 제어 전략

출금/이체 등의 주요 쓰기 기능들에 대해 아래와 같은 고민 후, **계좌 단위의 Lock**을 적용하여 제어하는 방식을 선택했습니다.

### 낙관적 Lock VS 비관적 Lock

낙관적 락 방식을 사용하면 충돌확률이 적을 때 성능을 확보할 수 있지만, 재시도했음에도 충돌할 경우 실패하거나, 이벤트 등으로 남겨 추후 될때까지 다시 실행하는 설계가 필요할 것입니다. 하지만 재시도하더라도 한도초과 등의 검증을 수반하는 등 출금/이체 기능은 재시도 비용이 크다고 생각했습니다.

또한 사용자가 송금/출금 기능을 사용했을 때 처리되거나 명확한 실패 이유(잔액 부족/한도초과 등)을 기대하게됨을 고려해 낙관적 Lock 방식은 배제하기로 결정했습니다.

### 계좌 로드 시점 Lock VS 원자적 업데이트

송금/출금하기 위한 계좌를 조회하는 시점부터 Lock을 점유하게되면 다른 트랜잭션에서 Lock 점유 대기시간이 길어질 수 있어, 계좌 현재잔액을 갱신할 때, DB 레벨에서 원자적으로 처리하는 방식(ex: 현재잔액 - 출금액)을 고려해보았습니다.

하지만 이 방식을 사용하려면 동시성 상황이 발생했을 때, JPA의 **영속성 컨텍스트가 알고있는 상태와 DB가 Update를 처리하는 시점의 상태가 불일치**할 수 있다는 문제가 있습니다. 이 문제를 해결하려면 결국 DB에 보내는 쿼리에 (ex: amount≥0, status=ACTIVE …) 등과 같이 **도메인 규칙이 포함되어 흩어지게** 됩니다. 또한 만약 **에러가 발생**하면 DB가 던지기 때문에 조건이 많아질수록 왜 실패했는지 **원인이 불분명**해지게되어 **사용자에게 명확한 실패원인을 제공하기가 어렵다**는 문제가 존재했습니다.

DDD 방식의 설계 관점에서 이 방식은 도메인 객체가 규칙을 가지고 있는 의미 자체를 퇴색되게 만든다고 생각했습니다. 따라서 조회 시점의 엔티티 상태를 가지고 도메인 규칙을 적용하고 이를 일관되게 DB에 반영할 수 있도록 조회 시점 계좌 단위로 Lock을 적용하기로 결정했습니다.

<br/>

## 🔬 업데이트 전략

헥사고날 아키텍처를 적용하여 도메인 객체와 영속성 객체를 분리한 상태이기에, **PersistenceAdapter** 계층에서 상태를 업데이트하려면 기존 조회되었던 엔티티 정보를 가져올 방법이 필요했습니다. 이를 위해 **Loaded 패턴**을 적용하여 내부 계층(Domain/Application)은 엔티티 객체의 존재를 모른 상태로 도메인 상태만 변경하고, **PersistenceAdapter** 계층에서 이를 그대로 가져와 엔티티에 적용해 더티체킹 기능을 적극 활용하는 방식을 선택했습니다.

<br/>

## 📦 도메인 객체 생성 전략

- 생성자는 외부로부터 은닉해두고, 팩토리 메서드를 정의하여 항상 의도에 맞게 객체가 생성될 수 있도록 하였습니다.
- 팩토리 메서드 내부에서 VO들을 생성해 조립하되, 각 VO들이 생성될 때 항상 불변식을 체크하여, 완성된 도메인 객체는 항상 유효함을 보장할 수 있도록 하였습니다.